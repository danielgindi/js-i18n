{"version":3,"file":"i18n.js","sources":["src/utils.js","src/string_case_permutations.js","src/date_formats.js","src/printf_specs.js","src/i18n.js"],"sourcesContent":["// Helper function to extend an object using a synthetic object structure from dotted syntax to a real nested structure.\r\nfunction extendDotted(target, data) {\r\n    if (data == null) return;\r\n    let dotted, targetDotted, i;\r\n    for (let key in data) {\r\n        if (!data.hasOwnProperty(key) || !data[key]) continue;\r\n        dotted = key.split('.');\r\n        targetDotted = target;\r\n        for (i = 0; i < dotted.length - 1; i++) {\r\n            targetDotted = targetDotted[dotted[i]];\r\n        }\r\n        targetDotted[dotted[dotted.length - 1]] = data[key];\r\n    }\r\n}\r\n\r\nconst ESCAPE_REGEX = /([\\/()[\\]?{}|*+-\\\\:])/g;\r\n\r\nfunction regexEscape(string) {\r\n    return string.replace(ESCAPE_REGEX, '\\\\$1');\r\n}\r\n\r\nfunction arrayToRegex(array) {\r\n    let regex = '';\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (i > 0) regex += '|';\r\n        regex += regexEscape(array[i]);\r\n    }\r\n    return regex;\r\n}\r\n\r\n/**\r\n * Pad a value with characters on the left\r\n * @param {string|Number} value the value to pad\r\n * @param {Number} length minimum length for the output\r\n * @param {string} ch the character to use for the padding\r\n * @returns {*}\r\n */\r\nfunction padLeft(value, length, ch) {\r\n    value = value.toString();\r\n    while (value.length < length)\r\n        value = ch + value;\r\n    return value;\r\n}\r\n\r\nexport {extendDotted, regexEscape, arrayToRegex, padLeft};","function recurse(results, lower, upper, hasCase, pre) {\r\n\r\n    const len = lower.length;\r\n    let currenLen = pre.length;\r\n\r\n    while (currenLen < len && !hasCase[currenLen]) {\r\n        pre += lower[currenLen++];\r\n    }\r\n\r\n    if (currenLen === len) {\r\n        return results.push(pre);\r\n    }\r\n\r\n    recurse(results, lower, upper, hasCase, pre + lower[currenLen]);\r\n    recurse(results, lower, upper, hasCase, pre + upper[currenLen]);\r\n}\r\n\r\n/**\r\n * Generate an array of all lowercase-uppercase combinations of a given string\r\n * @param {string} text\r\n * @returns {string[]}\r\n */\r\nfunction generateAllCasePermutations(text) {\r\n    text = text + '';\r\n    if (!text) return null;\r\n\r\n    const results = [];\r\n    const lower = text.split('');\r\n    const upper = [];\r\n    const hasCase = [];\r\n\r\n    let i = 0;\r\n    const len = text.length;\r\n    for (; i < len; i++) {\r\n        lower[i] = lower[i].toLowerCase();\r\n        upper[i] = lower[i].toUpperCase();\r\n        hasCase[i] = upper[i] !== lower[i];\r\n    }\r\n\r\n    recurse(results, lower, upper, hasCase, '');\r\n\r\n    return results;\r\n}\r\n\r\nexport {generateAllCasePermutations};","import {generateAllCasePermutations} from './string_case_permutations.js';\r\nimport {padLeft, arrayToRegex} from './utils.js';\r\n\r\nconst DATE_FORMAT_REGEX = /d{1,4}|M{1,4}|yy(?:yy)?|([HhmsTt])\\1?|[LloSZ]|UTC|('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")|(\\[[^\\]\\\\]*(?:\\\\.[^\\]\\\\]*)*])/g;\r\nconst DATE_TIMEZONE_REGEX = /\\b(?:[PMCEA][SDP]T|[a-zA-Z ]+ (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)?(?:[-+]\\d{4})?)\\b/g;\r\nconst DATE_TIMEZONE_CLIP_REGEX = /[^-+\\dA-Z]/g;\r\n\r\n/** @typedef {{d: function, D: function, M: function, y: function, H: function, m: function, s: function, L: function, o: function, utcd: function, utc: function}} FlagMap */\r\n\r\n/** @type {FlagMap} */\r\nconst DATE_FLAG_SUBMAP_LOCAL = {\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'd': d => d.getDate(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'D': d => d.getDay(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'M': d => d.getMonth(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'y': d => d.getFullYear(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'H': d => d.getHours(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'm': d => d.getMinutes(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 's': d => d.getSeconds(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'L': d => d.getMilliseconds(),\r\n    /** @param {Date} d */\r\n    /** @returns {number} */ 'o': d => 0,\r\n    /** @param {Date} d */\r\n    /** @returns {string} */ 'utcd': d => ((d + '').match(DATE_TIMEZONE_REGEX) || ['']).pop().replace(DATE_TIMEZONE_CLIP_REGEX, ''),\r\n    /** @param {Date} d */\r\n    /** @returns {string} */ 'utc': d => {\r\n        let z = d.getTimezoneOffset();\r\n        const s = (z > 0 ? '-' : '+');\r\n        z = z < 0 ? -z : z;\r\n        const zm = z % 60;\r\n        return s + padLeft((z - zm) / 60, 2, '0') + (zm ? padLeft(zm, 2, '0') : '');\r\n    }\r\n};\r\n\r\n/** @type {FlagMap} */\r\nconst DATE_FLAG_SUBMAP_UTC = {\r\n    /** @param {Date} d */ /** @returns {number} */ 'd': d => d.getUTCDate(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'D': d => d.getUTCDay(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'M': d => d.getUTCMonth(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'y': d => d.getUTCFullYear(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'H': d => d.getUTCHours(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'm': d => d.getUTCMinutes(),\r\n    /** @param {Date} d */ /** @returns {number} */ 's': d => d.getUTCSeconds(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'L': d => d.getUTCMilliseconds(),\r\n    /** @param {Date} d */ /** @returns {number} */ 'o': d => d.getTimezoneOffset(),\r\n    /** @param {Date} d */ /** @returns {string} */ 'utcd': () => \"UTC\",\r\n    /** @param {Date} d */ /** @returns {string} */ 'utc': () => \"Z\"\r\n};\r\n\r\nconst DATE_FLAG_MAP = {\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'd': (o, fmap) => fmap.d(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'dd': (o, fmap) => padLeft(fmap.d(o), 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'ddd': (o, fmap, culture) => culture['weekdays_short'][fmap.D(o)],\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'dddd': (o, fmap, culture) => culture['weekdays'][fmap.D(o)],\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'M': (o, fmap) => fmap.M(o) + 1,\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'MM': (o, fmap) => padLeft(fmap.M(o) + 1, 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'MMM': (o, fmap, culture) => culture['months_short'][fmap.M(o)],\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'MMMM': (o, fmap, culture) => culture['months'][fmap.M(o)],\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'yy': (o, fmap) => String(fmap.y(o)).slice(2),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'yyyy': (o, fmap) => fmap.y(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {number} */\r\n    'h': (o, fmap) => fmap.H(o) % 12 || 12,\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'hh': (o, fmap) => padLeft(fmap.H(o) % 12 || 12, 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'H': (o, fmap) => fmap.H(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'HH': (o, fmap) => padLeft(fmap.H(o), 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'm': (o, fmap) => fmap.m(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'mm': (o, fmap) => padLeft(fmap.m(o), 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    's': (o, fmap) => fmap.s(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'ss': (o, fmap) => padLeft(fmap.s(o), 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'l': (o, fmap) => padLeft(fmap.L(o), 3, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'L': (o, fmap) => {\r\n        const L = fmap.L(o);\r\n        return padLeft(L > 99 ? Math.round(L / 10) : L, 2, '0');\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'f': (o, fmap) => Math.floor(fmap.L(o) / 100).toString(),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'ff': (o, fmap) => padLeft(Math.floor(fmap.L(o) / 10), 2, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'fff': (o, fmap) => padLeft(fmap.L(o), 3, '0'),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'ffff': (o, fmap) => padLeft(fmap.L(o), 3, '0') + '0',\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'fffff': (o, fmap) => padLeft(fmap.L(o), 3, '0') + '00',\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'ffffff': (o, fmap) => padLeft(fmap.L(o), 3, '0') + '000',\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'fffffff': (o, fmap) => padLeft(fmap.L(o), 3, '0') + '0000',\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'F': (o, fmap) => {\r\n        const v = Math.floor(fmap.L(o) / 100);\r\n        if (v === 0) return '';\r\n        return v.toString();\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'FF': (o, fmap) => {\r\n        const v = Math.floor(fmap.L(o) / 10);\r\n        if (v === 0) return '';\r\n        return padLeft(v, 2, '0');\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'FFF': (o, fmap) => {\r\n        const v = fmap.L(o);\r\n        if (v === 0) return '';\r\n        return padLeft(v, 3, '0');\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'FFFF': (o, fmap) => {\r\n        const v = fmap.L(o);\r\n        if (v === 0) return '';\r\n        return padLeft(v, 3, '0') + '0';\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'FFFFF': (o, fmap) => {\r\n        const v = fmap.L(o);\r\n        if (v === 0) return '';\r\n        return padLeft(v, 3, '0') + '00';\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'FFFFFF': (o, fmap) => {\r\n        const v = fmap.L(o);\r\n        if (v === 0) return '';\r\n        return padLeft(v, 3, '0') + '000';\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'FFFFFFF': (o, fmap) => {\r\n        const v = fmap.L(o);\r\n        if (v === 0) return '';\r\n        return padLeft(v, 3, '0') + '0000';\r\n    },\r\n\r\n    't': (o, fmap, culture) => fmap.H(o) < 12 ?\r\n        culture['am_short_lower'] || 'a' :\r\n        culture['pm_short_lower'] || 'p',\r\n\r\n    'tt': (o, fmap, culture) => fmap.H(o) < 12 ?\r\n        culture['am_lower'] || 'am' :\r\n        culture['am_lower'] || 'pm',\r\n\r\n    'T': (o, fmap, culture) => fmap.H(o) < 12 ?\r\n        culture['am_short_upper'] || 'A' :\r\n        culture['pm_short_upper'] || 'P',\r\n\r\n    'TT': (o, fmap, culture) => fmap.H(o) < 12 ?\r\n        culture['am_upper'] || 'AM' :\r\n        culture['pm_upper'] || 'PM',\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'Z': (o, fmap) => fmap.utc(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'UTC': (o, fmap) => fmap.utcd(o),\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'o': (o, fmap) => {\r\n        o = fmap.o(o);\r\n        return (o > 0 ? \"-\" : \"+\") + padLeft(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4, '0')\r\n    },\r\n\r\n    /** @param {FlagMap} fmap */ /** @return {string} */\r\n    'S': (o, fmap) => {\r\n        const d = /**@type number*/fmap.d(o);\r\n        return [\"th\", \"st\", \"nd\", \"rd\"][d % 10 > 3 ? 0 : (d % 100 - d % 10 !== 10) * d % 10]\r\n    }\r\n};\r\n\r\nconst DATE_PARSER_FORMAT_REGEX = /('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')|(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")|(\\[[^\\]\\\\]*(?:\\\\.[^\\]\\\\]*)*])|yyyy|yy|MMMM|MMM|MM|M|dddd|ddd|dd|d|HH|H|hh|h|mm|m|ss|s|l|L|f|ff|fff|ffff|fffff|ffffff|fffffff|F|FF|FFF|FFFF|FFFFF|FFFFFF|FFFFFFF|tt|t|TT|T|Z|UTC|o|S|.+?/g;\r\n\r\nconst DATE_PARSER_MAP = {\r\n    'yyyy': (c, s) => s ? '[0-9]{4}' : '[0-9]{2}|[0-9]{4}',\r\n    'yy': () => '[0-9]{2}',\r\n    'MMMM': (c) => arrayToRegex(c['months']),\r\n    'MMM': (c) => arrayToRegex(c['months_short']),\r\n    'MM': (c, s) => s ? '[0-9]{2}' : '[0-9]{1,2}',\r\n    'M': () => '[0-9]{1,2}',\r\n    'dddd': (c) => arrayToRegex(c['days']),\r\n    'ddd': (c) => arrayToRegex(c['days_short']),\r\n    'dd': (c, s) => s ? '[0-9]{2}' : '[0-9]{1,2}',\r\n    'd': () => '[0-9]{1,2}',\r\n    'HH': (c, s) => s ? '[0-9]{2}' : '[0-9]{1,2}',\r\n    'H': () => '[0-9]{1,2}',\r\n    'hh': (c, s) => s ? '[0-9]{2}' : '[0-9]{1,2}',\r\n    'h': () => '[0-9]{1,2}',\r\n    'mm': (c, s) => s ? '[0-9]{2}' : '[0-9]{1,2}',\r\n    'm': () => '[0-9]{1,2}',\r\n    'ss': (c, s) => s ? '[0-9]{2}' : '[0-9]{1,2}',\r\n    's': () => '[0-9]{1,2}',\r\n    'l': () => '[0-9]{3}',\r\n    'L': () => '[0-9]{2}',\r\n    'f': () => '[0-9]{1}',\r\n    'ff': () => '[0-9]{2}',\r\n    'fff': () => '[0-9]{3}',\r\n    'ffff': () => '[0-9]{4}',\r\n    'fffff': () => '[0-9]{5}',\r\n    'ffffff': () => '[0-9]{6}',\r\n    'fffffff': () => '[0-9]{7}',\r\n    'F': () => '[0-9]{0,1}',\r\n    'FF': () => '[0-9]{0,2}',\r\n    'FFF': () => '[0-9]{0,3}',\r\n    'FFFF': () => '[0-9]{0,4}',\r\n    'FFFFF': () => '[0-9]{0,5}',\r\n    'FFFFFF': () => '[0-9]{0,6}',\r\n    'FFFFFFF': () => '[0-9]{0,7}',\r\n    'tt': (c) => {\r\n        const am1 = c['am_lower'] || 'am';\r\n        const pm1 = c['pm_lower'] || 'pm';\r\n        const am2 = c['am_upper'] || 'AM';\r\n        const pm2 = c['pm_upper'] || 'PM';\r\n\r\n        let all = generateAllCasePermutations(am1)\r\n            .concat(generateAllCasePermutations(pm1));\r\n\r\n        if (am1.toLowerCase() !== am2.toLowerCase()) {\r\n            all = all.concat(generateAllCasePermutations(am2));\r\n        }\r\n\r\n        if (pm1.toLowerCase() !== pm2.toLowerCase()) {\r\n            all = all.concat(generateAllCasePermutations(pm2));\r\n        }\r\n\r\n        return arrayToRegex(all);\r\n    },\r\n    't': (c) => {\r\n        const am1 = c['am_short_lower'] || 'a';\r\n        const pm1 = c['pm_short_lower'] || 'p';\r\n        const am2 = c['am_short_upper'] || 'A';\r\n        const pm2 = c['pm_short_upper'] || 'P';\r\n\r\n        let all = generateAllCasePermutations(am1)\r\n            .concat(generateAllCasePermutations(pm1));\r\n\r\n        if (am1.toLowerCase() !== am2.toLowerCase()) {\r\n            all = all.concat(generateAllCasePermutations(am2));\r\n        }\r\n\r\n        if (pm1.toLowerCase() !== pm2.toLowerCase()) {\r\n            all = all.concat(generateAllCasePermutations(pm2));\r\n        }\r\n\r\n        return arrayToRegex(all);\r\n    },\r\n    'TT': (c, s) => DATE_PARSER_MAP['tt'](c, s),\r\n    'T': (c, s) => DATE_PARSER_MAP['t'](c, s),\r\n    'Z': () => 'Z|(?:GMT|UTC)?[+-][0-9]{2,4}(?:\\\\([a-zA-Z ]+ (?:Standard|Daylight|Prevailing) Time\\\\))?',\r\n    'UTC': () => '[+-][0-9]{2,4}',\r\n    'o': () => '[+-][0-9]{4}',\r\n    'S': () => 'th|st|nd|rd'\r\n};\r\n\r\nexport {\r\n    DATE_FORMAT_REGEX,\r\n    DATE_FLAG_SUBMAP_LOCAL,\r\n    DATE_FLAG_SUBMAP_UTC,\r\n    DATE_FLAG_MAP,\r\n    DATE_PARSER_FORMAT_REGEX,\r\n    DATE_PARSER_MAP\r\n};","import {padLeft} from './utils.js';\r\n\r\nconst DEFAULT_DECIMAL_SEPARATOR = (1.1).toLocaleString().substr(1, 1);\r\n\r\nconst DEFAULT_THOUSANDS_SEPARATOR = (1000).toLocaleString().length === 5\r\n    ? (1000).toLocaleString().substr(1, 1)\r\n    : (DEFAULT_DECIMAL_SEPARATOR === ',' ? '.' : ',');\r\n\r\n//const DEFAULT_DECIMAL_SEPARATOR_REGEX = new RegExp('\\\\' + DEFAULT_DECIMAL_SEPARATOR, 'g');\r\n\r\n/**\r\n * This will process value with printf specifier format\r\n * @param {*} value the value to process\r\n * @param {string?} specifiers the printf style specifiers. i.e. '2.5f', 'E', '#x'\r\n * @param {string?} decimalSign the decimal separator character to use\r\n * @param {string?} thousandsSign the thousands separator character to use\r\n * @returns {string}\r\n */\r\nfunction applySpecifiers(value, specifiers, decimalSign, thousandsSign) {\r\n    if (!specifiers) return value;\r\n\r\n    const type = specifiers[specifiers.length - 1];\r\n    specifiers = specifiers.substr(0, specifiers.length - 1);\r\n\r\n    const isNumeric =\r\n        type === 'b' ||\r\n        type === 'c' ||\r\n        type === 'd' ||\r\n        type === 'i' ||\r\n        type === 'e' ||\r\n        type === 'E' ||\r\n        type === 'f' ||\r\n        type === 'g' ||\r\n        type === 'o' ||\r\n        type === 'u' ||\r\n        type === 'x' ||\r\n        type === 'X';\r\n    const isDecimalNumeric =\r\n        type === 'e' ||\r\n        type === 'E' ||\r\n        type === 'f' ||\r\n        type === 'g';\r\n    const isUpperCase =\r\n        type === 'E' ||\r\n        type === 'X';\r\n\r\n    let forceSign, spaceSign, radiiOrDecimalSign, padZero, padCount, hasThousands, precision;\r\n\r\n    if (isNumeric) {\r\n        if (typeof value !== 'number') {\r\n            value = parseInt(value, 10);\r\n        }\r\n        if (type === 'u') {\r\n            value = value >>> 0;\r\n        }\r\n\r\n        const parsedSpecifiers = specifiers.match(/(\\+)?( )?(#)?(0)?([0-9]+)?(,)?(.([0-9]+))?/);\r\n        forceSign = parsedSpecifiers[1] === '+';\r\n        spaceSign = parsedSpecifiers[2] === ' ';\r\n        radiiOrDecimalSign = parsedSpecifiers[3] === '#';\r\n        padZero = parsedSpecifiers[4] === '0';\r\n        padCount = parsedSpecifiers[5] ? parseInt(parsedSpecifiers[5], 10) : 0;\r\n        hasThousands = parsedSpecifiers[6];\r\n        precision = parsedSpecifiers[8];\r\n\r\n        if (precision) {\r\n            precision = parseInt(precision, 10);\r\n        }\r\n\r\n        decimalSign = decimalSign || DEFAULT_DECIMAL_SEPARATOR;\r\n        thousandsSign = thousandsSign || DEFAULT_THOUSANDS_SEPARATOR;\r\n    }\r\n\r\n    if (type === 'b') {\r\n        value = (/**@type number*/value).toString(2);\r\n    } else if (type === 'c') {\r\n        value = String.fromCharCode(value);\r\n    } else if (type === 'd' || type === 'i' || type === 'u') {\r\n        value = (/**@type number*/value).toString();\r\n    } else if (type === 'e' || type === 'E') {\r\n        value = (precision !== undefined\r\n            ? (/**@type number*/value).toExponential(parseInt(precision, 10))\r\n            : (/**@type number*/value).toExponential()).toString();\r\n    } else if (type === 'f') {\r\n        value = (precision !== undefined\r\n            ? parseFloat(value).toFixed(parseInt(precision, 10))\r\n            : parseFloat(value)).toString();\r\n    } else if (type === 'g') {\r\n        value = parseFloat(value).toString();\r\n        if (precision !== undefined) {\r\n            const decimalIdx = value.indexOf('.');\r\n            if (decimalIdx > -1) {\r\n                value = value.substr(0, decimalIdx + (precision > 0 ? 1 : 0) + precision);\r\n            }\r\n        }\r\n    } else if (type === 'o') {\r\n        value = (/**@type number*/value).toString(8);\r\n    } else if (type === 'x' || type === 'X') {\r\n        value = (/**@type number*/value).toString(16);\r\n    } else if (type === 's') {\r\n        value = value.toString();\r\n        if (precision !== undefined) {\r\n            value.substr(0, precision);\r\n        }\r\n    } else {\r\n        value = value.toString();\r\n    }\r\n\r\n    if (type === 'd' || type === 'i' || type === 'u' || type === 'x' || type === 'x' || type === 'X' || type === 'o') {\r\n        if (precision !== undefined) {\r\n            if (precision === 0 && value === '0') {\r\n                value = '';\r\n            } else {\r\n                value = padLeft(value, precision, '0');\r\n            }\r\n        }\r\n    }\r\n\r\n    if (value.length === 0) {\r\n        return value;\r\n    }\r\n\r\n    if (isDecimalNumeric) {\r\n        if (radiiOrDecimalSign && value.indexOf('.') === -1) {\r\n            value += '.';\r\n        }\r\n        value = value.replace(/\\./g, decimalSign);\r\n    }\r\n\r\n    if (isUpperCase) {\r\n        value = value.toUpperCase();\r\n    }\r\n\r\n    if (hasThousands) {\r\n        let decIndex = value.indexOf(decimalSign);\r\n        if (decIndex === -1) {\r\n            decIndex = value.length;\r\n        }\r\n        const signIndex = value.charAt(0) === '-' ? 1 : 0;\r\n        if (decIndex - signIndex > 3) {\r\n            let sepValue = '';\r\n            const major = value.substr(signIndex, decIndex - signIndex);\r\n            let fromIndex = 0, toIndex = major.length % 3;\r\n            while (fromIndex < major.length) {\r\n                if (fromIndex > 0) {\r\n                    sepValue += thousandsSign;\r\n                }\r\n                sepValue += major.substring(fromIndex, toIndex);\r\n                fromIndex = toIndex;\r\n                toIndex = fromIndex + 3;\r\n            }\r\n            value = (signIndex ? '-' : '') + sepValue + value.substr(decIndex);\r\n        }\r\n    }\r\n\r\n    if (isNumeric) {\r\n        const sign = (value.charAt(0) === '-' ? '-' : (forceSign ? '+' : '')) || (spaceSign ? ' ' : '');\r\n\r\n        // Remove the - sign\r\n        if (sign === '-') {\r\n            value = value.substr(1);\r\n        }\r\n\r\n        let radiiSign = '';\r\n\r\n        // Prefix with the radii sign\r\n        if (radiiOrDecimalSign) {\r\n            if (type === 'x' || type === 'X') {\r\n                radiiSign = '0x';\r\n            } else if (type === 'o') {\r\n                radiiSign = '0';\r\n            }\r\n        }\r\n\r\n        // Zero padding - should be like \"0x00005\" for length of 7, where the radii sign is before padding\r\n        if (padCount && padZero) {\r\n            value = padLeft(value, padCount - sign.length - radiiSign.length, '0');\r\n        }\r\n\r\n        value = sign + radiiSign + value;\r\n\r\n        // Space padding - should be like \"    0x5\" for length of 7, where the radii sign is after padding\r\n        if (padCount && !padZero) {\r\n            value = padLeft(value, padCount, ' ');\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport {applySpecifiers};","'use strict';\r\n\r\nimport {extendDotted, regexEscape} from './utils.js';\r\nimport {\r\n    DATE_FORMAT_REGEX,\r\n    DATE_FLAG_SUBMAP_LOCAL,\r\n    DATE_FLAG_SUBMAP_UTC,\r\n    DATE_FLAG_MAP,\r\n    DATE_PARSER_FORMAT_REGEX,\r\n    DATE_PARSER_MAP\r\n} from './date_formats.js';\r\nimport {applySpecifiers} from './printf_specs.js';\r\n\r\n/**\r\n *\r\n * To add a language, call i18n.add('language-code', {translation}, {options})\r\n * Where options takes the following keys:\r\n * \"plural\": function that takes a number, and returns a key suffix for plural form of that count.\r\n * \"decimal\": decimal separator character. The default is auto-detected from the browser locale\r\n * \"thousands\": thousands separator character. The default is auto-detected from the browser locale\r\n *\r\n */\r\n\r\nconst DEFAULT_DECIMAL_SEPARATOR = (1.1).toLocaleString().substr(1, 1);\r\n\r\nlet activeLanguage = '';\r\nlet fallbackLanguage = '';\r\nlet active = null;\r\n\r\nconst locs = {}; // Here we will keep i18n objects, each key is a language code\r\nconst originalLocs = {}; // Here we will keep original localizations before using extendLanguage\r\n\r\n/**\r\n * The default plural form specifier.\r\n * This function returns a specifier for plural form, for the specified count.\r\n * @param {Number} count the number that we need to inspect\r\n * @returns {string}\r\n */\r\nconst defaultPlural = function (count) {\r\n    if (count === 0) return 'zero';\r\n    if (count === 1) return 'one';\r\n    return 'plural';\r\n};\r\n\r\n/**\r\n * Encodes the value {value} using the specified {encoding}\r\n * @param {string} value the value to encode\r\n * @param {string} encoding for filters\r\n * @returns {*}\r\n */\r\nconst encodeValue = function (value, encoding) {\r\n    if (encoding === 'html') {\r\n        value = (value == null ? '' : (value + '')).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/'/g, \"&#39;\").replace(/\"/g, \"&quot;\");\r\n    }\r\n    else if (encoding === 'htmll') {\r\n        value = (value == null ? '' : (value + '')).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/'/g, \"&#39;\").replace(/\"/g, \"&quot;\").replace(/\\n/g, \"<br />\");\r\n    }\r\n    else if (encoding === 'json') {\r\n        value = JSON.stringify(value);\r\n    }\r\n    else if (encoding === 'url') {\r\n        value = encodeURIComponent(value);\r\n    }\r\n    else if (encoding === 'lower') {\r\n        value = (value + '').toLowerCase();\r\n    }\r\n    else if (encoding === 'upper') {\r\n        value = (value + '').toUpperCase();\r\n    }\r\n    else if (encoding === 'upperfirst') {\r\n        value = value + '';\r\n        value = value[0].toUpperCase() + value.substr(1).toLowerCase();\r\n    }\r\n    else if (encoding.substr(0, 7) === 'printf ') {\r\n        const localeOptions = active.options;\r\n        value = applySpecifiers(value, encoding.substr(7), localeOptions.decimal, localeOptions.thousands);\r\n    }\r\n\r\n    return value;\r\n};\r\n\r\n/** @typedef i18n */\r\nconst i18n = {\r\n\r\n    /**\r\n     * Add a language to the localization object\r\n     * @public\r\n     * @param {string} langCode language code\r\n     * @param {Object} data localization object\r\n     * @param {AddLanguageOptions?} options options for this language\r\n     * @returns {i18n} self\r\n     */\r\n    add: function (langCode, data, options) {\r\n        options = options || {};\r\n\r\n        const locOptions = {};\r\n        locOptions.plural = options.plural || defaultPlural;\r\n        locOptions.decimal = options.decimal || DEFAULT_DECIMAL_SEPARATOR;\r\n        locOptions.thousands = options.thousands || (locOptions.decimal === ',' ? '.' : ',');\r\n        locOptions.decimalOrThousandsRegex = new RegExp(\r\n            '(' + regexEscape(locOptions.decimal) +\r\n            ')|(' + regexEscape(locOptions.thousands) + ')', 'g');\r\n\r\n        locs[langCode] = {\r\n            code: langCode,\r\n            data: data,\r\n            options: locOptions\r\n        };\r\n\r\n        if (!activeLanguage) {\r\n            activeLanguage = langCode;\r\n            active = locs[langCode];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get a language object from the localization\r\n     * @public\r\n     * @param {string} lang language code\r\n     * @param {boolean?} tryFallbacks should we try to search in fallback scenarios i.e. 'en' for 'en-US'\r\n     * @returns {{ code: string, data: Object, options: Object }} language object\r\n     */\r\n    getLanguage: function (lang, tryFallbacks) {\r\n        if (tryFallbacks) {\r\n            if (lang === 'iw') lang = 'he'; // Fallback from Google's old spec, if the setting came from an old Android device\r\n            if (!lang) {\r\n                lang = this.getAvailableLanguages()[0];\r\n            }\r\n            let found = null;\r\n            while (typeof lang === 'string') {\r\n                if ((found = locs[lang])) break;\r\n\r\n                let idx = lang.lastIndexOf('-');\r\n\r\n                if (idx < 0)\r\n                    idx = lang.lastIndexOf('_');\r\n\r\n                if (idx > 0)\r\n                    lang = lang.substr(0, idx);\r\n                else break;\r\n            }\r\n\r\n            if (!found) {\r\n                lang = this.getAvailableLanguages()[0];\r\n                found = locs[lang];\r\n            }\r\n\r\n            return found;\r\n        } else {\r\n            return locs[lang];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieve a i18n value/object\r\n     * Accepted arguments are in the following formats:\r\n     *  (String keypath, [Boolean original], [Object options])\r\n     *  (String key, String key, String key, [Boolean original], [Object options])\r\n     *  (Array keypath, [Boolean original], [Object options])\r\n     *\r\n     * \"keypath\" is the path to the localized value.\r\n     * When the keypath is a String, each part is separated by a period.\r\n     * When the keypath is an Array, each part is a single part in the path.\r\n     *\r\n     * \"original\" specifies whether to access the original language, if the current language was extended. Default is false.\r\n     * \"options\" contains values that can be used in the localization,\r\n     *   and possibly the \"count\" property which is used for plural values,\r\n     *   or the \"gender\" property for selecting a gender from the target value.\r\n     *\r\n     * @public\r\n     * @param {...}\r\n     * @returns {*} localized value or object\r\n     */\r\n    t: function () {\r\n        const args = arguments;\r\n        let argIndex = 0,\r\n            keys,\r\n            useOriginal = false,\r\n            locale,\r\n            tryFallback = true,\r\n            options,\r\n            i,\r\n            len;\r\n\r\n        // Normalize key(s)\r\n        if (typeof args[0] === 'string' && typeof args[1] !== 'string') {\r\n            keys = args[argIndex++];\r\n            if (keys.length === 0) {\r\n                keys = [];\r\n            } else {\r\n                keys = keys.split('.');\r\n            }\r\n        } else if (typeof args[0] === 'object' && 'length' in args[0]) {\r\n            keys = args[argIndex++];\r\n        } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {\r\n            let arg;\r\n            keys = [];\r\n            for (len = args.length; argIndex < len; argIndex++) {\r\n                arg = args[argIndex];\r\n                if (typeof arg === 'string') {\r\n                    keys.push(arg);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // `useOriginal` argument\r\n        options = args[argIndex++];\r\n        if (typeof options === 'boolean') {\r\n            useOriginal = options;\r\n            options = args[argIndex];\r\n        }\r\n\r\n        // Choose locale\r\n        if (useOriginal) {\r\n            locale = originalLocs[activeLanguage] || active;\r\n        } else {\r\n            locale = active;\r\n        }\r\n\r\n        let loc = locale.data;\r\n\r\n        // If no key is specified, return the root namespace\r\n        if (!keys.length) {\r\n            return loc;\r\n        }\r\n\r\n        // `while` because we might try multiple times,\r\n        // like first try with active locale, second time with fallback locale.\r\n        while (true) {\r\n\r\n            if (options && typeof options['count'] === 'number') { // Try for plural form\r\n\r\n                // Loop on all of them except the last. We are going to test the last key combined with plural specifiers\r\n                for (i = 0, len = keys.length - 1; i < len; i++) {\r\n                    loc = loc[keys[i]];\r\n\r\n                    // Avoid stepping into an undefined. Make systems more stable.\r\n                    // Anyone who queries for an invalid `t(...)` should handle the `undefined` himself.\r\n                    if (loc === undefined) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                let pluralSpec = locale.options.plural;\r\n                pluralSpec = pluralSpec(options['count']);\r\n\r\n                const key = keys[keys.length - 1]; // This is the last key in the keys array\r\n\r\n                if (pluralSpec && loc[key + '_' + pluralSpec]) {\r\n                    // We have a match for the plural form\r\n                    loc = loc[key + '_' + pluralSpec];\r\n                } else {\r\n                    // Take the bare one\r\n                    loc = loc[key];\r\n                }\r\n\r\n            } else {\r\n                // No need for the plural form, as no 'count' was specified\r\n\r\n                for (i = 0, len = keys.length; i < len; i++) {\r\n                    loc = loc[keys[i]];\r\n\r\n                    // Avoid stepping into an undefined. Make systems more stable.\r\n                    // Anyone who queries for an invalid `t(...)` should handle the `undefined` himself.\r\n                    if (loc === undefined) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (loc === undefined &&\r\n                tryFallback &&\r\n                fallbackLanguage &&\r\n                fallbackLanguage !== activeLanguage) {\r\n\r\n                tryFallback = false;\r\n\r\n                if (locs.hasOwnProperty(fallbackLanguage)) {\r\n                    locale = locs[fallbackLanguage];\r\n                    loc = locale.data;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            break;\r\n        }\r\n\r\n        if (options) {\r\n\r\n            if (typeof options['gender'] === 'string') { // Try for gender form\r\n\r\n                if (typeof loc === 'object' &&\r\n                    !(loc instanceof Array)) {\r\n\r\n                    const gender = options['gender'];\r\n                    let genderized;\r\n\r\n                    // Allow any gender, you can invent new ones...\r\n                    genderized = loc[gender];\r\n\r\n                    if (genderized === undefined) {\r\n\r\n                        // Fallback for male/female to m/f\r\n                        if (gender === 'male') {\r\n                            genderized = loc['m'];\r\n                        } else if (gender === 'female') {\r\n                            genderized = loc['f'];\r\n                        }\r\n\r\n                        // Fallbacks for neutral gender\r\n                        if (genderized === undefined) {\r\n                            genderized = loc['neutral'];\r\n                        }\r\n\r\n                        if (genderized === undefined) {\r\n                            genderized = loc['n'];\r\n                        }\r\n\r\n                        if (genderized === undefined) {\r\n                            genderized = loc[''];\r\n                        }\r\n\r\n                        // Default fallback\r\n\r\n                        if (genderized === undefined) {\r\n                            genderized = loc;\r\n                        }\r\n                    }\r\n\r\n                    loc = genderized;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // Process special value contents based on whether there are `options` provided,\r\n        // or the value contains a special character\r\n        if (options ||\r\n            (typeof loc === 'string' && (loc.indexOf('{') > -1 || loc.indexOf('t(') > -1))) {\r\n            loc = i18n.processLocalizedString(loc, options);\r\n        }\r\n\r\n        return loc;\r\n    },\r\n\r\n    /**\r\n     * Get the decimal seperator for the active locale\r\n     * @public\r\n     * @returns {string} decimal separator\r\n     */\r\n    getDecimalSeparator: function () {\r\n        return active.options.decimal;\r\n    },\r\n\r\n    /**\r\n     * Get the thousands seperator for the active locale\r\n     * @public\r\n     * @returns {string} thousands separator\r\n     */\r\n    getThousandsSeparator: function () {\r\n        return active.options.thousands;\r\n    },\r\n\r\n    /**\r\n     * Set current active language using a language code.\r\n     * The function will fall back from full to two-letter ISO codes (en-US to en) and from bad Android like codes (en_US to en).\r\n     * @public\r\n     * @param {string} lang the language code to use\r\n     * @returns {i18n} self\r\n     */\r\n    setActiveLanguage: function (lang) {\r\n        const found = this.getLanguage(lang, true);\r\n        active = found;\r\n        activeLanguage = found.code;\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the language code of the fallback language.\r\n     * By default there's no fallback language, so <code>undefined</code> could be returned when a key is not localized.\r\n     * The function will fall back from full to two-letter ISO codes (en-US to en) and from bad Android like codes (en_US to en).\r\n     * Note: For performance reasons, the fallback happens only if <code>setFallbackLanguage(...)</code> is called when all languages are already added. Otherwise, the specified language code is used as it is.\r\n     * @public\r\n     * @param {string} lang the language code to use\r\n     * @returns {i18n} self\r\n     */\r\n    setFallbackLanguage: function (lang) {\r\n        const found = this.getLanguage(lang, true);\r\n        fallbackLanguage = found ? found.code : lang;\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set current active language using a language code found in the document's lang attribute or a relevant meta tag.\r\n     * Calls setActiveLanguage to do the dirty work after detecting language code.\r\n     * @public\r\n     * @returns {i18n} self\r\n     */\r\n    setActiveLanguageFromMetaTag: function () {\r\n        let lang = document.documentElement.getAttribute('lang') || document.documentElement.getAttribute('xml:lang');\r\n        if (!lang) {\r\n            const metas = document.getElementsByTagName('meta');\r\n            let i = 0, meta;\r\n            for (; i < metas.length; i++) {\r\n                meta = metas[i];\r\n                if ((meta.getAttribute('http-equiv') || '').toLowerCase() === 'content-language') {\r\n                    lang = meta.getAttribute('content');\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this.setActiveLanguage(lang);\r\n    },\r\n\r\n    /**\r\n     * Get the current active language code.\r\n     * @public\r\n     * @returns {string} current active language code\r\n     */\r\n    getActiveLanguage: function () {\r\n        return activeLanguage;\r\n    },\r\n\r\n    /**\r\n     * Get an array of the available language codes\r\n     * @public\r\n     * @returns {string[]} array of the available language codes\r\n     */\r\n    getAvailableLanguages: function () {\r\n        const langs = [];\r\n        for (let key in locs) {\r\n            if (!locs.hasOwnProperty(key)) continue;\r\n            langs.push(key);\r\n        }\r\n        return langs;\r\n    },\r\n\r\n    /**\r\n     * Extend a specific language with data from a localized object.\r\n     * In order to allow easy storage and retrieval of extensions from DBs, the extension data is built with\r\n     *   dotted syntax instead of a hieararchy of objects. i.e {\"parent.child\": \"value\"}\r\n     * @public\r\n     * @param {string} lang language code\r\n     * @param {Object} data localization object\r\n     * @returns {i18n} self\r\n     */\r\n    extendLanguage: function (lang, data) {\r\n        try {\r\n            if (locs[lang]) {\r\n                if (!originalLocs[lang]) { // Back it up first\r\n                    originalLocs[lang] = JSON.parse(JSON.stringify(locs[lang]));\r\n                }\r\n                extendDotted(locs[lang].data, data);\r\n            }\r\n        } catch (e) { }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Extend the entire languages array, with the help of the extendLanguage function.\r\n     * @public\r\n     * @param {Object} data the localization extension object. each language as the key and extension object as the value.\r\n     * @returns {i18n} self\r\n     */\r\n    extendLanguages: function (data) {\r\n        try {\r\n            for (let lang in data) {\r\n                if (!data.hasOwnProperty(lang)) continue;\r\n                if (locs[lang]) {\r\n                    if (!originalLocs[lang]) { // Back it up first\r\n                        originalLocs[lang] = JSON.parse(JSON.stringify(locs[lang]));\r\n                    }\r\n                    extendDotted(locs[lang].data, data[lang]);\r\n                }\r\n            }\r\n        } catch (e) { }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieve a localized string of a physical file size, assuming that the \"size_abbrs\" key is available.\r\n     * @public\r\n     * @param {number} bytes the number of bytes\r\n     * @returns {LocalizedPhysicalFileSize} localized size\r\n     */\r\n    physicalSize: function (bytes) {\r\n        let ret;\r\n        const loc = i18n.t('size_abbrs');\r\n        if (bytes < 100) ret = {size: bytes, name: loc['b']};\r\n        else if (bytes < 101376) ret = {size: bytes / 1024.0, name: loc['kb']};\r\n        else if (bytes < 103809024) ret = {size: bytes / 1024.0 / 1024.0, name: loc['mb']};\r\n        else if (bytes < 106300440576) ret = {size: bytes / 1024.0 / 1024.0 / 1024.0, name: loc['gb']};\r\n        else ret = {size: bytes / 1024.0 / 1024.0 / 1024.0 / 1024.0, name: loc['tb']};\r\n        ret.size = (Math.ceil(ret.size * 100) / 100); // Max two decimal points\r\n        return ret;\r\n    },\r\n\r\n    /**\r\n     * Format a date to a localized string, assuming that the \"calendar\" key is available.\r\n     * Supports all formatting codes known to humanity.\r\n     * @public\r\n     * @param {Date|string|number} date The date to format\r\n     * @param {string} format The format\r\n     * @param {string|Object|null|?} culture Can accept a culture code, a culture object,\r\n     *                                       or a simple \"calendar\" object which contains the keys \"months\", \"months_short\", \"days\" and \"days_short\"\r\n     * @returns {string} A localized date\r\n     */\r\n    formatDate: function (date, format, culture) {\r\n\r\n        if (culture && typeof culture === 'string') {\r\n            culture = i18n.getLanguage(culture, true);\r\n\r\n            if (culture) {\r\n                culture = culture['calendar'];\r\n            }\r\n        }\r\n\r\n        culture = culture || i18n.t('calendar') || {};\r\n\r\n        // Passing date through Date applies Date.parse, if necessary\r\n        if (date == null) {\r\n            date = new Date();\r\n        } else if (typeof date === 'string') {\r\n            date = i18n.parseDate(date, null, culture);\r\n        } else if (date instanceof Date) {\r\n            // date = new Date(date);\r\n        } else if (typeof date === 'number') {\r\n            date = new Date(date);\r\n        } else {\r\n            date = NaN;\r\n        }\r\n\r\n        if (isNaN(date)) throw new SyntaxError(\"invalid date\");\r\n\r\n        let utc = false;\r\n\r\n        if (!format) {\r\n            format = 'yyyy-MM-dd'; // ISO\r\n        }\r\n\r\n        // Allow setting the utc argument via the a special UTC: specifier\r\n        if (format.substr(0, 4) === 'UTC:') {\r\n            utc = true;\r\n            format = format.slice(4);\r\n        }\r\n\r\n        // Allow setting the utc argument via the Z specifier\r\n        if (format.charAt(format.length - 1) === 'Z') {\r\n            utc = true;\r\n        }\r\n\r\n        const f = utc ? DATE_FLAG_SUBMAP_UTC : DATE_FLAG_SUBMAP_LOCAL;\r\n\r\n        return format.replace(\r\n            DATE_FORMAT_REGEX,\r\n                token => (token in DATE_FLAG_MAP)\r\n                    ? (DATE_FLAG_MAP[token])(date, f, culture)\r\n                    : token.slice(1, token.length - 1)\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Parses a date from user input, based on a supplied format. This is the counterpart of the formatDate function.\r\n     * Supports all formatting codes known to humanity.\r\n     * Will automatically fall back if missing a digit i.e 1/2/34 for dd/MM/yyyy, unless `strict` is specified.\r\n     * Forgiving behavior with \"incorrect\" separators, i.e 01.05 instead of 01/05, unless `strict` is specified.\r\n     * If year is missing, it will default to current year. Anything else will default to zero.\r\n     *\r\n     * This function actually uses the `createDateParser(...)` function, and caches the result.\r\n     * @public\r\n     * @expose\r\n     * @param {string} date The date to parse\r\n     * @param {string?} format The format. Defaults to UTC ISO. (yyyy-MM-DD'T'HH:mm:ssZ)\r\n     * @param {string|Object|null|?} culture Can accept a culture code, a culture object,\r\n     *                                       or a simple \"calendar\" object which contains the keys \"months\", \"months_short\", \"days\" and \"days_short\"\r\n     * @param {boolean?} strict Should the parser be strict? false by default, forgiving missing digits etc.\r\n     * @returns {Date} The parsed date\r\n     */\r\n    parseDate: function (date, format, culture, strict) {\r\n\r\n        if (culture && typeof culture === 'string') {\r\n            culture = i18n.getLanguage(culture, true);\r\n\r\n            if (culture) {\r\n                culture = culture['calendar'];\r\n            }\r\n        }\r\n\r\n        culture = culture || i18n.t('calendar') || {};\r\n\r\n        if (!format) {\r\n            if ('parse' in Date) {\r\n                return new Date(date);\r\n            } else {\r\n                let parsed = this.parseDate(date, 'yyyy-MM-dd\\'T\\'HH:mm:ss[.FFFFFFF]Z', culture, true);\r\n                if (isNaN(+parsed)) parsed = this.parseDate(date, 'yyyy-MM-dd', culture, true);\r\n                if (isNaN(+parsed)) parsed = this.parseDate(date, 'ddd, dd, MMM yyyy HH:mm:ss Z', culture, true);\r\n                if (isNaN(+parsed)) parsed = this.parseDate(date, 'dddd, dd-MMM-yy HH:mm:ss Z', culture, true);\r\n                if (isNaN(+parsed)) parsed = this.parseDate(date, 'ddd MMM d HH:mm:ss yyyy', culture, true);\r\n                return parsed;\r\n            }\r\n        }\r\n\r\n        let compiled = culture[strict ? '_compiledParsersE' : '_compiledParsers'];\r\n        if (!compiled) {\r\n            culture[strict ? '_compiledParsersE' : '_compiledParsers'] = compiled = {};\r\n        }\r\n\r\n        if (!compiled[format]) {\r\n            compiled[format] = i18n.createDateParser(format, culture, strict);\r\n        }\r\n\r\n        return compiled[format](date, culture);\r\n    },\r\n\r\n    /**\r\n     * Creates a date parser. This is generally used (and cached) by `parseDate(...)`.\r\n     * Supports all formatting codes known to humanity.\r\n     * Will automatically fall back if missing a digit i.e 1/2/34 for dd/MM/yyyy, unless `strict` is specified.\r\n     * Forgiving behavior with \"incorrect\" separators, i.e 01.05 instead of 01/05, unless `strict` is specified.\r\n     * If year is missing, it will default to current year. Anything else will default to zero.\r\n     * @public\r\n     * @expose\r\n     * @param {string} format The format\r\n     * @param {Object} culture An object which contains the keys \"months\", \"months_short\", \"days\" and \"days_short\"\r\n     * @param {boolean} strict Should the parser be strict? false by default, forgiving missing digits etc.\r\n     * @returns {function(string):Date} The parser function\r\n     */\r\n    createDateParser: function (format, culture, strict) {\r\n\r\n        let regex = '';\r\n        const regexParts = [];\r\n\r\n        const processFormat = format => {\r\n            const formatParts = format.match(DATE_PARSER_FORMAT_REGEX);\r\n\r\n            let i, count, part, shouldStrict;\r\n\r\n            // Remove all empty groups\r\n            for (i = 0, count = formatParts.length; i < count; i++) {\r\n                if (formatParts[i].length === 0 || formatParts[i] === '[]') {\r\n                    formatParts.splice(i, 1);\r\n                    i--;\r\n                    count--;\r\n                }\r\n            }\r\n\r\n            // Go over all parts in the format, and create the parser regex part by part\r\n            for (i = 0, count = formatParts.length; i < count; i++) {\r\n                part = formatParts[i];\r\n                if (part[0] === '[' && part[part.length - 1] === ']') {\r\n                    regex += '(?:';\r\n                    processFormat(part.substr(1, part.length - 2));\r\n                    regex += ')?';\r\n                } else if (DATE_PARSER_MAP.hasOwnProperty(part)) {\r\n                    // An actually recognized part\r\n                    shouldStrict = strict || // We are specifically instructed to use strict mode\r\n                        (i > 0 && DATE_PARSER_MAP.hasOwnProperty(formatParts[i - 1])) || // Previous part is not some kind of a boundary\r\n                        (i < count - 1 && DATE_PARSER_MAP.hasOwnProperty(formatParts[i + 1])); // Next part is not some kind of a boundary\r\n\r\n                    regex += '(' + DATE_PARSER_MAP[part](culture, shouldStrict) + ')';\r\n                    regexParts.push(part);\r\n                } else {\r\n                    // A free text node\r\n\r\n                    // Remove enclosing quotes if there are...\r\n                    if (part[0] === \"'\") {\r\n                        part = part.replace(/'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'/, '$1');\r\n                    } else if (part[0] === '\"') {\r\n                        part = part.replace(/\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"/, '$1');\r\n                    }\r\n\r\n                    part = part.replace(/\\\\\\\\/g, '\\\\'); // Unescape\r\n                    if (!strict && (part === '/' || part === '.' || part === '-')) {\r\n                        regex += '([/\\\\.-])';\r\n                    } else {\r\n                        regex += '(' + regexEscape(part) + ')';\r\n                    }\r\n                    regexParts.push('');\r\n                }\r\n            }\r\n        };\r\n\r\n        processFormat(format);\r\n\r\n        regex = new RegExp('^' + regex + '$');\r\n\r\n        // This is for calculating which side to go for 2 digit years\r\n        const baseYear = Math.floor((new Date()).getFullYear() / 100) * 100;\r\n\r\n        // Return a parser function\r\n        return date => {\r\n            date = date + '';\r\n            const parts = date.match(regex);\r\n            if (!parts) return null;\r\n\r\n            parts.splice(0, 1); // Remove main capture group 0\r\n\r\n            const now = new Date(),\r\n                nowYear = now.getFullYear();\r\n            let year = null, month = null, day = null,\r\n                hours = null, hours12 = false, hoursTT, minutes = null,\r\n                seconds = null, milliseconds = null,\r\n                timezone = null;\r\n\r\n            let i = 0;\r\n            const len = parts.length;\r\n            let part, tmp;\r\n            for (; i < len; i++) {\r\n                part = parts[i];\r\n                switch (regexParts[i]) {\r\n                    case 'yyyy':\r\n                    case 'yy':\r\n                        year = parseInt(part, 10);\r\n                        if (year < 100) {\r\n                            year += baseYear;\r\n                            if (year - nowYear > 50) {\r\n                                year -= 100;\r\n                            } else if (nowYear - year > 50) {\r\n                                year += 100;\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case 'MMMM':\r\n                        tmp = culture['months'].indexOf(part);\r\n                        if (tmp > -1) month = tmp;\r\n                        break;\r\n\r\n                    case 'MMM':\r\n                        tmp = culture['months_short'].indexOf(part);\r\n                        if (tmp > -1) month = tmp;\r\n                        break;\r\n\r\n                    case 'MM':\r\n                    case 'M':\r\n                        month = parseInt(part, 10) - 1;\r\n                        break;\r\n\r\n                    case 'dddd':\r\n                        tmp = culture['days'].indexOf(part);\r\n                        if (tmp > -1) day = tmp;\r\n                        break;\r\n\r\n                    case 'ddd':\r\n                        tmp = culture['days_short'].indexOf(part);\r\n                        if (tmp > -1) day = tmp;\r\n                        break;\r\n\r\n                    case 'dd':\r\n                    case 'd':\r\n                        day = parseInt(part, 10);\r\n                        break;\r\n\r\n                    case 'HH':\r\n                    case 'H':\r\n                        hours = parseInt(part, 10);\r\n                        hours12 = false;\r\n                        break;\r\n\r\n                    case 'hh':\r\n                    case 'h':\r\n                        hours = parseInt(part, 10);\r\n                        hours12 = true;\r\n                        break;\r\n\r\n                    case 'mm':\r\n                    case 'm':\r\n                        minutes = parseInt(part, 10);\r\n                        break;\r\n\r\n                    case 'ss':\r\n                    case 's':\r\n                        seconds = parseInt(part, 10);\r\n                        break;\r\n\r\n                    case 'l':\r\n                        milliseconds = parseInt(part, 10);\r\n                        break;\r\n\r\n                    case 'L':\r\n                        milliseconds = parseInt(part, 10);\r\n                        if (milliseconds < 10) {\r\n                            milliseconds *= 100;\r\n                        } else {\r\n                            milliseconds *= 10;\r\n                        }\r\n                        break;\r\n\r\n                    case 'f':\r\n                    case 'ff':\r\n                    case 'fff':\r\n                    case 'ffff':\r\n                    case 'fffff':\r\n                    case 'ffffff':\r\n                    case 'fffffff':\r\n                    case 'F':\r\n                    case 'FF':\r\n                    case 'FFF':\r\n                    case 'FFFF':\r\n                    case 'FFFFF':\r\n                    case 'FFFFFF':\r\n                    case 'FFFFFFF':\r\n                        if (part.length > 3) {\r\n                            part = part.substr(0, 3) + '.' + part.substr(3);\r\n                        } else if (part.length < 3) {\r\n                            while (part.length < 3) {\r\n                                part += '0';\r\n                            }\r\n                        }\r\n                        milliseconds = parseFloat(part);\r\n                        break;\r\n\r\n                    case 'tt':\r\n                    case 't':\r\n                    case 'TT':\r\n                    case 'T':\r\n                        if (hours12) {\r\n                            hoursTT = part.toLowerCase();\r\n                        }\r\n                        break;\r\n\r\n                    case 'Z':\r\n                    case 'UTC':\r\n                    case 'o':\r\n                        const tz = part.match(/(Z)|(?:GMT|UTC)?([+-][0-9]{2,4})(?:\\([a-zA-Z ]+ (?:Standard|Daylight|Prevailing) Time\\))?/);\r\n                        if (tz[1] === 'Z') {\r\n                            timezone = 0;\r\n                        } else if (tz[2]) {\r\n                            timezone = (parseInt(tz[2].substr(1, 2), 10) || 0) * 60 + (parseInt(tz[2].substr(3), 10) || 0);\r\n                            if (tz[2].charAt(0) === '-') {\r\n                                timezone = -timezone;\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (year === null) year = now.getFullYear();\r\n            if (month === null) month = now.getMonth();\r\n            if (day === null) day = 1;\r\n            if (hours12) {\r\n                if (hoursTT === (culture['am_lower'] || 'am').toLowerCase() ||\r\n                    hoursTT === (culture['am_short_lower'] || 'a').toLowerCase()) {\r\n                    if (hours === 12) hours = 0;\r\n                } else if (hoursTT === (culture['pm_lower'] || 'pm').toLowerCase() ||\r\n                    hoursTT === (culture['pm_short_lower'] || 'p').toLowerCase()) {\r\n                    if (hours < 12) hours += 12;\r\n                }\r\n            }\r\n            const parsedDate = new Date(year, month, day, hours || 0, minutes || 0, seconds || 0, milliseconds || 0);\r\n            if (timezone !== null) {\r\n                timezone += parsedDate.getTimezoneOffset();\r\n            }\r\n            parsedDate.setMinutes(parsedDate.getMinutes() - timezone);\r\n\r\n            return parsedDate;\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Try to detect, based on the browser's localization, which is the short date format appropriate.\r\n     * So allegedly, a US user will have MM/dd/yyyy and GB will have d/MM/yyyy.\r\n     * Currently browsers do not seem to behave and use the correct formats of the OS!\r\n     * @public\r\n     * @expose\r\n     * @param {string} fallback a fallback date for a case where the browser does not support this functionality.\r\n     * @returns {string} the detected format, the fallback, or dd/MM/yyyy as default.\r\n     */\r\n    detectShortDateFormat: function (fallback) {\r\n        if (!Date.prototype.toLocaleDateString) return fallback || 'dd/MM/yyyy';\r\n\r\n        return new Date(2013, 1, 1).toLocaleDateString()\r\n            .replace(/\\b2013\\b/, 'yyyy').replace(/\\b13\\b/, 'yy')\r\n            .replace(/\\b02\\b/, 'MM').replace(/\\b2\\b/, 'M')\r\n            .replace(/\\b01\\b/, 'dd').replace(/\\b1\\b/, 'd');\r\n    },\r\n\r\n    /**\r\n     * Format a number for display using the correct decimal separator detected from the browser.\r\n     * @public\r\n     * @expose\r\n     * @param {number|string|null} value the value to format.\r\n     * @param {boolean=} thousands should we add a thousands separator\r\n     * @returns {string} The formatted number as string.\r\n     *                   If null or empty string is supplied, then an empty string is returned.\r\n     *                   If a string was supplied, it is returned as-is.\r\n     */\r\n    displayNumber: function (value, thousands) {\r\n        if (value === '' || value == null) return '';\r\n        if (typeof value === 'number') {\r\n            value = value.toString();\r\n\r\n            const decimalSep = active.options.decimal,\r\n                thousandsSep = active.options.thousands;\r\n\r\n            if (decimalSep !== '.') {\r\n                value = value.replace(/\\./g, decimalSep);\r\n            }\r\n            if (thousands) {\r\n                let decIndex = value.indexOf(decimalSep);\r\n                if (decIndex === -1) {\r\n                    decIndex = value.length;\r\n                }\r\n                const sign = value.charAt(0) === '-' ? 1 : 0;\r\n                if (decIndex - sign > 3) {\r\n                    let sepValue = '';\r\n                    const major = value.substr(sign, decIndex - sign);\r\n                    let fromIndex = 0, toIndex = major.length % 3;\r\n                    while (fromIndex < major.length) {\r\n                        if (fromIndex > 0) {\r\n                            sepValue += thousandsSep;\r\n                        }\r\n                        sepValue += major.substring(fromIndex, toIndex);\r\n                        fromIndex = toIndex;\r\n                        toIndex = fromIndex + 3;\r\n                    }\r\n                    value = (sign ? '-' : '') + sepValue + value.substr(decIndex);\r\n                }\r\n            }\r\n            return value;\r\n        }\r\n        return value.toLocaleString();\r\n    },\r\n\r\n    /**\r\n     * Parses a number from user input using the correct decimal separator detected from the browser.\r\n     *\r\n     * By default it will behave like `parseFloat`, where thousands separators are not supported.\r\n     * If `thousands` is `true`, then it will allow parsing with the separator.\r\n     * @public\r\n     * @expose\r\n     * @param {number|string|null} value the value to parse.\r\n     * @param {boolean?} [thousands=false] - Don't break when there are thousands separators in the value\r\n     * @returns {number|null} The parsed number.\r\n     *                   If null or empty string is supplied, then null is returned.\r\n     *                   If a number was supplied, it is returned as-is.\r\n     */\r\n    parseNumber: function (value, thousands) {\r\n        if (value === '' || value == null) return null;\r\n\r\n        if (typeof value !== 'number') {\r\n            return parseFloat(\r\n                value.replace(active.options.decimalOrThousandsRegex, function (g0, dec, tho) {\r\n                    if (dec) return '.';\r\n                    if (tho) return thousands ? '' : ',';\r\n                    return g0;\r\n                })\r\n            );\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * Process a localized string.\r\n     *\r\n     * Pass 1:\r\n     *      Look for localization value specified in the form of:\r\n     *          {key.subkey}\r\n     *          {key.subkey|filter|filter...}\r\n     *\r\n     *      Possible filters are:\r\n     *          html\r\n     *          htmll - multiline HTML. replaces \\n with <br />\r\n     *          json\r\n     *          url\r\n     *          lower\r\n     *          upper\r\n     *          upperfirst\r\n     *          printf [print-specifier]\r\n     *\r\n     *      * `printf-specifier`s are C-style format specifiers. i.e. 2.5f\r\n     *      * The i18n keys will receive the `data` passed to `processLocalizedString`\r\n     *\r\n     *      And for placeholders from the passed options, in the form of:\r\n     *          {{count}}\r\n     *          {{data.value|filter|filter...}}\r\n     *\r\n     *          etc.\r\n     *\r\n     * Pass 2:\r\n     *      Look for i18n calls in the form of:\r\n     *          t(\"key.path\") t('key.path') t(key.path) or t(\"key.path\", {\"count\": 5})\r\n     *      Where the options part must be a valid JSON\r\n     *      This stage is affected by previous stages (i.e placeholders can be JSON encoded for t(...) calls\r\n     *\r\n     * localization format is {key.path[|filter][|filter]}\r\n     * Placeholder format is {{key.path[|filter][|filter]}}\r\n     *\r\n     * Printf specifiers are in this order:\r\n     *\r\n     *  \"[+][ ][#][0][width][,][.precision]\" and then one of [bcdieEfgouxXs]\r\n     *\r\n     * +            : Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers.\r\n     * (space)      : If no sign is going to be written, a blank space is inserted before the value.\r\n     * #            : For o, x or X specifiers the value is prefixed with 0, 0x or 0X respectively for values different than zero.\r\n     *                For with e, E, f, g it forces the written output to contain a decimal point even if no more digits follow\r\n     * 0            : Left-pads the number with zeroes (0) instead of spaces when padding is specified\r\n     * (width)      : Minimum number of characters to be printed, left-padded with spaces or zeroes.\r\n     *                If shorter than the number, then the number is not truncated.\r\n     * ,            : For d, i, u, f, g specifiers, adds thousand grouping characters\r\n     * (precision)  : For integer specifiers (d, i, u, o, x, X) - specifies the minimum number of digits to be written. Does not truncate, except for 0.\r\n     *                For e, E, f specifiers: this is the number of digits to be printed after the decimal point\r\n     *                For g specifier: This is the maximum number of significant digits to be printed.\r\n     *                For s: this is the maximum number of characters to be printed\r\n     *\r\n     * @param {string} value - the value to process\r\n     * @param {Object?} data - the data for post processing. Passed to {...} specifiers too.\r\n     * @returns {string} the processed value\r\n     */\r\n    processLocalizedString: function (value, data) {\r\n\r\n        if (typeof value !== 'string') return value;\r\n\r\n        value = value.replace(/(\\\\*)(\\{{1,2})([^|{}\"]+)((?:\\|[^|{}]+)*?)(}{1,2})/g, function () {\r\n\r\n            const precedingBackslahes = arguments[1];\r\n            const openingBrackets = arguments[2];\r\n            const closingBrackets = arguments[5];\r\n\r\n            if ((precedingBackslahes.length & 1) === 1) {\r\n                return arguments[0].substr(precedingBackslahes.length - (precedingBackslahes.length - 1) / 2);\r\n            }\r\n\r\n            if (openingBrackets.length > closingBrackets.length) {\r\n                return arguments[0];\r\n            }\r\n\r\n            let value;\r\n            const key = arguments[3];\r\n            let i, len;\r\n\r\n            let filters = arguments[4];\r\n            if (filters)\r\n                filters = filters.split('|');\r\n\r\n            if (openingBrackets.length === 1) {\r\n\r\n                /** @type string|null */\r\n                let gender = null;\r\n                if (filters && filters[0][0] === 'g' && filters[0][1] === ':') {\r\n                    gender = i18n.t(filters[0].substr(2));\r\n\r\n                    if (gender === 'male') {\r\n                        gender = 'm';\r\n                    } else if (gender === 'female') {\r\n                        gender = 'f';\r\n                    }\r\n                }\r\n\r\n                if (gender !== null) {\r\n                    value = i18n.t(key + '.' + gender);\r\n                    if (value === undefined) value = i18n.t(key + '.neutral');\r\n                    if (value === undefined) value = i18n.t(key + '.');\r\n                    if (value === undefined) value = i18n.t(key + '.m');\r\n                    if (value === undefined) value = i18n.t(key + '.f');\r\n                } else {\r\n                    value = i18n.t(key, data);\r\n                }\r\n\r\n            } else {\r\n\r\n                const keys = key.split('.');\r\n                value = data;\r\n                for (i = 0, len = keys.length; i < len && value; i++) {\r\n                    value = value[keys[i]];\r\n                }\r\n                if (value == null) {\r\n                    value = '';\r\n                }\r\n\r\n            }\r\n\r\n            if (arguments[4]) {\r\n                filters = arguments[4].split('|');\r\n                for (i = 0, len = filters.length; i < len; i++) {\r\n                    if (!filters[i]) continue;\r\n                    value = encodeValue(value, filters[i]);\r\n                }\r\n            }\r\n\r\n            if (closingBrackets.length > openingBrackets.length) {\r\n                value = value + closingBrackets.substr(openingBrackets.length);\r\n            }\r\n\r\n            return (precedingBackslahes.length ?\r\n                precedingBackslahes.substr(precedingBackslahes.length / 2) :\r\n                '') + value;\r\n        });\r\n\r\n        value = value.replace(/t\\((\"[^\"]+?\"|'[^']+?'|[^,)]+?)(?:,\\s*(\\{.*?}))?\\)/g, function () {\r\n\r\n            let key = arguments[1],\r\n                options = arguments[2];\r\n            try {\r\n                key = JSON.parse(key);\r\n            } catch (e) {\r\n                return arguments[0];\r\n            }\r\n            if (options) {\r\n                try {\r\n                    options = JSON.parse(options);\r\n                } catch (e) {\r\n                    options = null;\r\n                }\r\n            }\r\n\r\n            return i18n.t(key, options);\r\n\r\n        });\r\n\r\n        return value;\r\n\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * @typedef {Object} LocalizedPhysicalFileSize\r\n * @property {number} size\r\n * @property {string} name\r\n * */\r\n/** */\r\n\r\n/**\r\n * This function returns a key suffix for plural form, for the specified count.\r\n * @typedef {function(count:number):string} PluralFormFunction\r\n * @param {number} count the number that we need to inspect\r\n * @returns {string}\r\n * */\r\n/** */\r\n\r\n/**\r\n * @typedef {Object} AddLanguageOptions\r\n * @property {PluralFormFunction} plural - function that takes a number, and returns a key suffix for plural form of that count.\r\n * @property {string} [decimal='.'] - decimal separator character. The default is auto-detected from the browser locale\r\n * @property {string} [thousands=','] - thousands separator character. The default is auto-detected from the browser locale\r\n * */\r\n/** */\r\n\r\nexport default i18n;\r\n"],"names":["extendDotted","target","data","dotted","targetDotted","i","key","hasOwnProperty","split","length","ESCAPE_REGEX","regexEscape","string","replace","arrayToRegex","array","regex","padLeft","value","ch","toString","generateAllCasePermutations","text","results","lower","upper","hasCase","len","toLowerCase","toUpperCase","recurse","pre","currenLen","push","DATE_FORMAT_REGEX","DATE_TIMEZONE_REGEX","DATE_TIMEZONE_CLIP_REGEX","DATE_FLAG_SUBMAP_LOCAL","d","getDate","D","getDay","M","getMonth","y","getFullYear","H","getHours","m","getMinutes","s","getSeconds","L","getMilliseconds","o","utcd","match","pop","utc","z","getTimezoneOffset","zm","DATE_FLAG_SUBMAP_UTC","getUTCDate","getUTCDay","getUTCMonth","getUTCFullYear","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","DATE_FLAG_MAP","fmap","culture","String","slice","Math","round","floor","v","abs","DATE_PARSER_FORMAT_REGEX","DATE_PARSER_MAP","c","am1","pm1","am2","pm2","all","concat","DEFAULT_DECIMAL_SEPARATOR","toLocaleString","substr","DEFAULT_THOUSANDS_SEPARATOR","activeLanguage","fallbackLanguage","active","locs","originalLocs","defaultPlural","count","encodeValue","encoding","JSON","stringify","encodeURIComponent","localeOptions","options","specifiers","decimalSign","thousandsSign","type","isNumeric","isDecimalNumeric","isUpperCase","forceSign","spaceSign","radiiOrDecimalSign","padZero","padCount","hasThousands","precision","parseInt","parsedSpecifiers","fromCharCode","undefined","toExponential","parseFloat","toFixed","decimalIdx","indexOf","decIndex","signIndex","charAt","sepValue","major","fromIndex","toIndex","substring","sign","radiiSign","applySpecifiers","decimal","thousands","i18n","add","langCode","locOptions","plural","decimalOrThousandsRegex","RegExp","code","this","getLanguage","lang","tryFallbacks","getAvailableLanguages","found","idx","lastIndexOf","t","args","arguments","keys","locale","argIndex","useOriginal","tryFallback","arg","loc","pluralSpec","Array","gender","genderized","processLocalizedString","getDecimalSeparator","getThousandsSeparator","setActiveLanguage","setFallbackLanguage","setActiveLanguageFromMetaTag","document","documentElement","getAttribute","metas","getElementsByTagName","meta","getActiveLanguage","langs","extendLanguage","parse","e","extendLanguages","physicalSize","bytes","ret","size","name","ceil","formatDate","date","format","Date","parseDate","NaN","isNaN","SyntaxError","f","token","strict","parsed","compiled","createDateParser","regexParts","processFormat","formatParts","part","shouldStrict","splice","baseYear","parts","now","nowYear","hoursTT","year","month","day","hours","hours12","minutes","seconds","milliseconds","timezone","tmp","tz","parsedDate","setMinutes","detectShortDateFormat","fallback","prototype","toLocaleDateString","displayNumber","decimalSep","thousandsSep","parseNumber","g0","dec","tho","precedingBackslahes","openingBrackets","closingBrackets","filters"],"mappings":"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"}